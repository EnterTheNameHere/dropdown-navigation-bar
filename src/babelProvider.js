
import { TextEditor } from 'atom'; // eslint-disable-line import/no-unresolved, no-unused-vars
import { TopScopeIdentifier } from './topScopeIdentifier';
import { Identifier } from './identifier';
import { EmptyIdentifier } from './emptyIdentifier';

const babelParser = require('@babel/parser');
// https://github.com/estree/estree

export class ProvidersRegistry {
    getProviderForTextEditor( textEditor ) {
        return new BabelProvider( textEditor );
    }
}

export class IdentifiersProvider {
    /**
     * Holds TextEditor instance this provider provides Identifiers for.
     * @type {TextEditor}
     *
     * @private
     */
    _textEditor = null;

    /**
     * Holds TopScopeIdentifier for TextEditor this provider provides for.
     * @type {TopScopeIdentifier}
     */
    _topScopeIdentifier = null;

    /**
     * Creates new IdentifierProvider for given TextEditor.
     * @param {TextEditor} textEditor
     */
    constructor( textEditor ) {
        if( !textEditor ) {
            throw new Error('textEditor argument must be valid instance of atom TextEditor!');
        }

        this._textEditor = textEditor;
        this._topScopeIdentifier = new TopScopeIdentifier( this._textEditor );
    }

    /**
     * Makes the Provider generate Identifiers for the TextEditor.
     *
     * @abstract
     * You want to override this function when creating custom IdentifiersProvider.
     * Perform parsing and populate the TopScopeIdentifier with Identifiers.
     */
    generateIdentifiers() {

    }

    /**
     * Returns TopScopeIdentifier with all Identifiers found in TextEditor's code.
     *
     * @return {TopScopeIdentifier} A TopScopeIdentifier for TextEditor.
     */
    getTopScopeIdentifier() {
        return this._topScopeIdentifier;
    }

    /**
     * Returns an array of all Identifiers of given `identifier` which
     * can have children (eg. classes, namespaces, enums etc.), with
     * TopScopeIdentifier at the top. TopScopeIdentifier must always
     * be present in the array, even if Provider is not able to provide
     * any other Identifiers.
     *
     * @param  {Identifier} [identifier] The parent Identifier we're getting children of. TopScopeIdentifier is default.
     * @return {Array<Identifier>} An array with all parent Identifiers with TopScopeIdentifier on top.
     * @abstract
     * You want to override this function when creating custom IdentifiersProvider.
     * Return Identifiers which belongs to the left dropdown box of NavigationBar - all the parents.
     */
    getIdentifiersForParentsDropbox( identifier ) { // eslint-disable-line no-unused-vars
        return [ this._topScopeIdentifier ];
    }

    /**
     * Returns an array of all children (eg. variables, properties, methods etc.)
     * of the given parent `identifier`, with {@link EmptyIdentifier} at the top.
     * {@link EmptyIdentifier} must always be present in the array even if `identifier`
     * itself have no other children.
     *
     * @param  {Identifier} [identifier] The parent Identifier we're getting children of. TopScopeIdentifier is default.
     * @return {Array<Identifier>}
     * @abstract
     * You want to override this function when creating custom IdentifiersProvider.
     * Return Identifiers which belongs to the right dropdown box of NavigationBar - all the children.
     */
    getIdentifiersForChildrenDropbox( identifier ) {
        if( identifier === null || identifier === undefined ) {
            identifier = this._topScopeIdentifier;
        }

        return [ new EmptyIdentifier(identifier), ...identifier.getChildren() ];
    }
}

/**
 * Provider uses Babel for parsing source code. It handles javascript, typescript and flow.
 */
export class BabelProvider extends IdentifiersProvider {
    /**
     * Holds esTree generated by Babel.
     * @type {object}
     */
    _esTree = null;

    /**
     * Holds instance of current Identifier. It's either TopScopeIdentifier,
     * a parent Identifier which can have children, or child Identifier.
     * @type {Identifier}
     */
    _currentIdentifier = null;

    /**
     * Holds instance of current EsTree node provider is processing.
     * @type {Object}
     */
    _currentEsTreeNode = null;

    /**
     * @override
     */
    generateIdentifiers() {
        this._topScopeIdentifier.removeAllChildren();
        this.parse();
        this.processEsTree();

        console.log(
            'BabelProvider finished',
            this._topScopeIdentifier
        );
    }

    /**
     * @override
     */
    getIdentifiersForParentsDropbox( identifier ) {
        if( identifier === null || identifier === undefined ) {
            identifier = this._topScopeIdentifier;
        }

        return [
            this._topScopeIdentifier,
            ...identifier.getChildren().filter( (ident) => {
                if( ident.isKind('class') ) {
                    return true;
                }
                return false;
            })
        ];
    }

    /**
     * @override
     */
    getIdentifiersForChildrenDropbox( identifier ) {
        if( identifier === null || identifier === undefined ) {
            identifier = this._topScopeIdentifier;
        }

        return [
            new EmptyIdentifier( identifier ),
            ...identifier.getChildren().filter( (ident) => {
                if( ident.isKind('variable')
                    || ident.isKind('function')
                    || ident.isKind('method')
                    || ident.isKind('property')
                    || ident.isKind('unimplemented')
                    || ident.isKind('export all')
                ) {
                    return true;
                }
                return false;
            })
        ];
    }

    /**
     * Parses source code from TextEditor with Babel.
     *
     * @private
     */
    parse() {
        const parserOptions = {
            errorRecovery: true,
            sourceType: 'module',
            plugins: [
                'asyncGenerators',
                'bigInt',
                'classProperties',
                'classPrivateProperties',
                'classPrivateMethods',
                [ 'decorators', { decoratorsBeforeExport: false } ],
                'doExpressions',
                'dynamicImport',
                'exportDefaultFrom',
                'exportNamespaceFrom',
                'functionBind',
                'functionSent',
                'importMeta',
                'logicalAssignment',
                'nullishCoalescingOperator',
                'numericSeparator',
                'objectRestSpread',
                'optionalCatchBinding',
                'optionalChaining',
                'partialApplication',
                //'pipelineOperator',
                'throwExpressions',
                'topLevelAwait'
            ]
        };

        try {
            this._esTree = babelParser.parse( this._textEditor.getBuffer().getText(), parserOptions );
        } catch( error ) {
            console.error( 'BabelProvider::parse caught exception:', error );
            this._esTree = null;
        }
    }

    /**
     * Processes EsTree generated by Babel, if parsing produced one.
     *
     * @private
     */
    processEsTree() {
        if( !this._esTree ) return;

        switch( this._esTree.type ) {
        case 'File':
            this.processFile( this._esTree, this._topScopeIdentifier );
            break;
        default:
            console.warn( 'BabelProvider::processEsTree: Unknown node type!', this._esTree.type );
            console.info( this._esTree );
        }
    }

    /*
        File:
        .comments   {Array}
        .end        {number}
        .errors     {Array}
        .loc        SourceLocation{start:{line,column}, end:{line,column}, source: string|null}
        .program    {Node}
        .start      {number}
        .type       'File'
     */
    processFile( node, parentIdentifier/*, currentIdentifier*/ ) {
        console.assert( node.type === 'File', 'Wrong node type!' );

        this.processProgram( node.program, parentIdentifier );
    }

    /*
        Program {
            body: [ Statement | ModuleDeclaration ];
            loc: SourceLocation | null;
            sourceType: "script" | "module";
            type: string;
        }

        Program:
        .body           {Array}
        .directives     {Array}
        .end            {number}
        .interpreter    {null}
        .loc            SourceLocation{start:{line,column}, end:{line,column}, source: string|null}
        .sourceType     {string}
        .start          {number}
        .type           'Program'
     */
    processProgram( node, parentIdentifier/*, currentIdentifier*/ ) {
        console.assert( node.type === 'Program', 'Wrong node type!' );

        for( const body of node.body ) {
            if( !this.processStatement( body, parentIdentifier ) ) {
                if( !this.processModuleDeclaration( body, parentIdentifier ) ) {
                    console.warn( 'BabelProvider::processProgram: Unknown program.body.type!', body.type );
                    console.info( 'Program', node );
                    console.info( 'esTree:', this._esTree );
                }
            }
        }
    }

    /*
        ModuleDeclaration: ExportAllDeclaration
            | ExportDefaultDeclaration
            | ExportNamedDeclaration
            | ImportDeclaration;
     */
    processModuleDeclaration( node, parentIdentifier/*, currentIdentifier*/ ) {
        switch( node.type ) {
        case 'ExportAllDeclaration':
            this.processExportAllDeclaration( node, parentIdentifier );
            break;
        case 'ExportDefaultDeclaration':
            this.processExportDefaultDeclaration( node, parentIdentifier );
            break;
        case 'ExportNamedDeclaration':
            this.processExportNamedDeclaration( node, parentIdentifier );
            break;
        case 'ImportDeclaration':
            this.processImportDeclaration( node, parentIdentifier );
            break;
        default:
            return false;
        }
        return true;
    }

    /*
        Statement: BlockStatement( FunctionBody )
            | BreakStatement
            | ContinueStatement
            | DebuggerStatement
            | Declaration( ClassDeclaration | FunctionDeclaration | VariableDeclaration )
            | DoWhileStatement
            | EmptyStatement
            | ExpressionStatement
            | ForInStatement
            | ForOfStatement
            | ForStatement
            | IfStatement
            | LabeledStatement
            | ReturnStatement
            | SwitchStatement
            | ThrowStatement
            | TryStatement
            | WhileStatement
            | WithStatement;
     */
    processStatement( node, parentIdentifier/*, currentIdentifier*/ ) {
        if( this.processDeclaration( node, parentIdentifier ) ) {
            return true;
        }

        switch( node.type ) {
        case 'FunctionBody':
            break;
        case 'BreakStatement':
        case 'ContinueStatement':
        case 'DebuggerStatement':
        case 'DoWhileStatement':
        case 'EmptyStatement':
        case 'ExpressionStatement':
        case 'ForInStatement':
        case 'ForOfStatement':
        case 'ForStatement':
        case 'IfStatement':
        case 'LabeledStatement':
        case 'ReturnStatement':
        case 'SwitchStatement':
        case 'ThrowStatement':
        case 'TryStatement':
        case 'WhileStatement':
        case 'WithStatement':
            console.info(`BabelProvider::processStatement: ${node.type} is ignored.`, node);
            break;
        default:
            return false;
        }
        return true;
    }

    /*
        Declaration: ClassDeclaration
            | FunctionDeclaration
            | VariableDeclaration;
     */
    processDeclaration( node, parentIdentifier, currentIdentifier ) {
        switch( node.type ) {
        case 'ClassDeclaration':
            this.processClassDeclaration( node, parentIdentifier, currentIdentifier );
            break;
        case 'FunctionDeclaration':
            this.processFunctionDeclaration( node, parentIdentifier, currentIdentifier );
            break;
        case 'VariableDeclaration':
            this.processVariableDeclaration( node, parentIdentifier, currentIdentifier );
            break;
        default:
            return false;
        }
        return true;
    }

    /*
        ExportAllDeclaration <: ModuleDeclaration {
            type: "ExportAllDeclaration";
            source: Literal;
            loc: SourceLocation | null;
            exported: Identifier | null;
        }
     */
    processExportAllDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExportAllDeclaration', 'Wrong node type!' );

        const exportAllIdentifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        if( node.exported ) {
            exportAllIdentifier.setName( this.getIdentifierAsString( node.exported ) );
        } else {
            exportAllIdentifier.setName('unnamed export');
        }
        exportAllIdentifier.addKind('export all');
    }

    /*
        ExportDefaultDeclaration <: ModuleDeclaration {
            type: "ExportDefaultDeclaration";
            loc: SourceLocation | null;
            declaration: AnonymousDefaultExportedFunctionDeclaration
                | FunctionDeclaration
                | AnonymousDefaultExportedClassDeclaration
                | ClassDeclaration
                | Expression;
        }
     */
    processExportDefaultDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExportDefaultDeclaration', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName('ExportDefaultDeclaration').addKind('unimplemented');
    }

    /*
        ExportNamedDeclaration <: ModuleDeclaration {
            type: "ExportNamedDeclaration";
            declaration: Declaration | null;
            specifiers: [ ExportSpecifier ];
            source: Literal | null;
            loc: SourceLocation | null;
        }

        ExportNamedDeclaration:
        .declaration        {Node}
        .end                {number}
        .loc                SourceLocation{start:{line,column}, end:{line,column}, source: string|null}
        .source             {Literal|null}
        .specifiers         {Array}
        .start              {number}
        .trailingComments   ['CommentBlock']
        .type               'ExportNamedDeclaration'
     */
    processExportNamedDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExportNamedDeclaration', 'Wrong node type!' );

        const exportedIdentifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        exportedIdentifier.addKind('export');
        if( node.specifiers.length > 0 ) {
            exportedIdentifier.addKind('multiple');
            for( const specifier of node.specifiers ) {
                const identifier = this.addNewIdentifier( exportedIdentifier );
                this.processExportSpecifier( specifier, exportedIdentifier, identifier );
            }
        }

        if( node.declaration !== null ) {
            this.processDeclaration( node.declaration, parentIdentifier, exportedIdentifier );
        }
    }

    /*
        ExportSpecifier <: ModuleSpecifier {
            type: "ExportSpecifier";
            exported: Identifier;
            loc: SourceLocation | null;
            local: Identifier;
        }
     */
    processExportSpecifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExportSpecifier', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.processIdentifier( node.local, parentIdentifier, identifier );
        identifier.getAdditionalDataMap().set( 'exported', this.getIdentifierName( node.exported ) );
    }

    /*
        VariableDeclaration <: Declaration {
            type: "VariableDeclaration";
            declarations: [ VariableDeclarator ];
            kind: "var" | "let" | "const";
            loc: SourceLocation | null;
        }
     */
    processVariableDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'VariableDeclaration', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        if( node.declarations > 1 ) {
            identifier.addKind('multiple');
            for( const variableDeclarator of node.declarations ) {
                const variableIdentifier = this.addNewIdentifier( parentIdentifier );
                this.processVariableDeclarator( variableDeclarator, identifier, variableIdentifier );
                variableIdentifier.addKind( node.kind );
                variableIdentifier.addKind('variable');
            }
        } else {
            this.processVariableDeclarator( node.declarations[0], parentIdentifier, identifier );
            identifier.addKind( node.kind );
            identifier.addKind('variable');
        }
    }

    /*
        VariableDeclarator <: Node {
            type: "VariableDeclarator";
            id: Pattern;
            init: Expression | null;
            loc: SourceLocation | null;
        }
     */
    processVariableDeclarator( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'VariableDeclarator', 'Wrong node type!' );

        return this.processPattern( node.id, parentIdentifier, currentIdentifier );
    }

    /*
        ClassDeclaration <: Class, Declaration {
            type: "ClassDeclaration";
            id: Identifier;
            loc: SourceLocation | null;
            superClass: Expression | null;
            body: ClassBody;
        }
     */
    processClassDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ClassDeclaration', 'Wrong node type!' );

        const classIdentifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        classIdentifier.addKind('class');
        this.processIdentifier( node.id, parentIdentifier, classIdentifier );
    }

    /*
        ClassBody <: Node {
            type: "ClassBody";
            body: [ MethodDefinition ];
            loc: SourceLocation | null;
        }
     */
    processClassBody( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ClassBody', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName('ClassBody').addKind('unimplemented');
    }

    /*
        MethodDefinition <: Node {
            type: "MethodDefinition";
            key: Expression;
            value: FunctionExpression;
            kind: "constructor" | "method" | "get" | "set";
            computed: boolean;
            static: boolean;
            loc: SourceLocation | null;
        }
     */
    processMethodDefinition( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'MethodDefinition', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName('MethodDefinition').addKind('unimplemented');
    }

    /*
        FunctionDeclaration <: Function, Declaration {
            type: "FunctionDeclaration";
            id: Identifier;
            loc: SourceLocation | null;
            async: boolean;
            generator: boolean;
            params: [ Pattern ];
            body: FunctionBody;
        }

        FunctionBody <: BlockStatement {
            body: [ Directive | Statement ];
        }
     */
    processFunctionDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'FunctionDeclaration', 'Wrong node type!' );

        const functionIdentifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        functionIdentifier.addKind('function');
        this.processIdentifier( node.id, parentIdentifier, functionIdentifier );
        if( node.async ) functionIdentifier.addKind('async');
        if( node.generator ) functionIdentifier.addKind('generator');
        // TODO: params array
    }

    /*
        ImportDeclaration <: ModuleDeclaration {
            type: "ImportDeclaration";
            source: Literal;
            specifiers: [ ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier ];
            loc: SourceLocation | null;
        }
     */
    processImportDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportDeclaration', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.addKind('import');
        identifier.setName('ImportDeclaration');
        for( const specifier of node.specifiers ) {
            switch( specifier.type ) {
            case 'ImportSpecifier':
                this.processImportSpecifier( specifier, parentIdentifier, identifier );
                break;
            case 'ImportDefaultSpecifier':
                this.processImportDefaultSpecifier( specifier, parentIdentifier, identifier );
                break;
            case 'ImportNamespaceSpecifier':
                this.processImportNamespaceSpecifier( specifier, parentIdentifier, identifier );
                break;
            default:
                console.warn( 'BabelProvider::processImportDeclaration: Unknown specifier.type!', specifier.type );
                console.info( 'Program', node );
            }
        }
    }

    /*
        ImportDefaultSpecifier <: ModuleSpecifier {
            type: "ImportDefaultSpecifier";
            loc: SourceLocation | null;
            local: Identifier;
        }
    */
    processImportDefaultSpecifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportDefaultSpecifier', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.processIdentifier( node.imported, parentIdentifier, identifier );
    }

    /*
        ImportExpression <: Expression {
            type: "ImportExpression";
            source: Expression;
            loc: SourceLocation | null;
        }
    */
    processImportExpression( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportExpression', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName('ImportExpression').addKind('unimplemented');
    }

    /*
        ImportNamespaceSpecifier <: ModuleSpecifier {
            type: "ImportNamespaceSpecifier";
            loc: SourceLocation | null;
            local: Identifier;
        }
    */
    processImportNamespaceSpecifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportNamespaceSpecifier', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.processIdentifier( node.local, parentIdentifier, identifier );
    }

    /*
        ImportSpecifier <: ModuleSpecifier {
            type: "ImportSpecifier";
            imported: Identifier;
            loc: SourceLocation | null;
            local: Identifier;
        }
    */
    processImportSpecifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportSpecifier', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.processIdentifier( node.imported, parentIdentifier, identifier );
        identifier.getAdditionalDataMap().set( 'local', this.getIdentifierName( node.local ) );
    }

    /*
        ExpressionStatement <: Statement {
            type: "ExpressionStatement";
            expression: Expression;
            loc: SourceLocation | null;
        }
     */
    processExpressionStatement( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExpressionStatement', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName('ExpressionStatement').addKind('unimplemented');
    }

    /*
        Pattern: ArrayPattern
            | AssignmentPattern
            | Identifier
            | MemberExpression
            | ObjectPattern
            | RestElement
     */
    processPattern( node, parentIdentifier, currentIdentifier ) {
        switch( node.type ) {
        case 'Identifier':
            this.processIdentifier( node, parentIdentifier, currentIdentifier );
            break;
        case 'ArrayPattern':
            this.processArrayPattern( node, parentIdentifier, currentIdentifier );
            break;
        case 'AssignmentPattern':
            this.processAssignmentPattern( node, parentIdentifier, currentIdentifier );
            break;
        case 'MemberExpression':
            this.processMemberExpression( node, parentIdentifier, currentIdentifier );
            break;
        case 'ObjectPattern':
            this.processObjectPattern( node, parentIdentifier, currentIdentifier );
            break;
        case 'RestElement':
            this.processRestElement( node, parentIdentifier, currentIdentifier );
            break;
        default:
            console.warn( 'BabelProvider::processPattern: Unknown Pattern type!', node.type );
            console.info( node );
        }
    }

    /*
        Identifier <: Expression, Pattern {
            type: "Identifier";
            name: string;
            loc: SourceLocation | null;
        }
     */
    processIdentifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'Identifier', 'Wrong node type!' );

        currentIdentifier.setName( node.name );
    }

    getIdentifierName( node ) {
        return node.name;
    }

    /*
        ArrayPattern <: Pattern {
            type: "ArrayPattern";
            elements: [ Pattern | null ];
            loc: SourceLocation | null;
        }
     */
    processArrayPattern( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ArrayPattern', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName( 'ArrayPattern' ).addKind('unimplemented');
    }

    /*
        AssignmentPattern <: Pattern {
            type: "AssignmentPattern";
            left: Pattern;
            right: Expression;
            loc: SourceLocation | null;
        }
     */
    processAssignmentPattern( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'AssignmentPattern', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName( 'AssignmentPattern' ).addKind('unimplemented');
    }

    /*
        MemberExpression <: Expression, Pattern, ChainElement {
            type: "MemberExpression";
            object: Expression | Super;
            property: Expression;
            computed: boolean;
            loc: SourceLocation | null;
            optional: boolean;
        }
     */
    processMemberExpression( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'MemberExpression', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName( 'MemberExpression' ).addKind('unimplemented');
    }

    /*
        ObjectPattern <: Pattern {
            type: "ObjectPattern";
            properties: [ AssignmentProperty | RestElement ];
            loc: SourceLocation | null;
        }
     */
    processObjectPattern( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ObjectPattern', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName( 'ObjectPattern' ).addKind('unimplemented');
    }

    /*
        RestElement <: Pattern {
            type: "RestElement";
            argument: Pattern;
            loc: SourceLocation | null;
        }
     */
    processRestElement( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'RestElement', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        identifier.setName( 'RestElement' ).addKind('unimplemented');
    }

    /**
     * Adds a new Identifier to `parentIdentifier` and returns the newly added Identifier.
     * @param {Identifier} parentIdentifier
     * @return {Identifier} Returns the newly added identifier.
     *
     * @throws {Error} When `parentIdentifier` is not given.
     */
    addNewIdentifier( parentIdentifier ) {
        if( !parentIdentifier ) {
            throw new Error('"parentIdentifier" is required argument.');
        }

        const identifier = new Identifier({ textEditor: this._textEditor, parent: parentIdentifier });
        parentIdentifier.addChild( identifier );
        return identifier;
    }
}



/*

Declaration: ClassDeclaration | FunctionDeclaration | VariableDeclaration;
Expression: ArrayExpression
    | ArrowFunctionExpression
    | AssignmentExpression
    | AwaitExpression
    | BinaryExpression
    | CallExpression
    | ChainExpression
    | ClassExpression
    | ConditionalExpression
    | FunctionExpression
    | Identifier
    | ImportExpression
    | Literal
    | LogicalExpression
    | MemberExpression
    | MetaProperty
    | NewExpression
    | ObjectExpression
    | SequenceExpression
    | TaggedTemplateExpression
    | TemplateLiteral
    | ThisExpression
    | UnaryExpression
    | UpdateExpression
    | YieldExpression
ModuleDeclaration: ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ImportDeclaration;
Pattern: ArrayPattern | AssignmentPattern | Identifier | MemberExpression | ObjectPattern | RestElement;
BlockStatement: FunctionBody
Statement: BlockStatement( FunctionBody )
    | BreakStatement
    | ContinueStatement
    | DebuggerStatement
    | Declaration( ClassDeclaration | FunctionDeclaration | VariableDeclaration )
    | DoWhileStatement
    | EmptyStatement
    | ExpressionStatement
    | ForInStatement
    | ForOfStatement
    | ForStatement
    | IfStatement
    | LabeledStatement
    | ReturnStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | WithStatement;

AnonymousDefaultExportedClassDeclaration <: Class {
    type: "ClassDeclaration";
    id: null;
    superClass: Expression | null;
    body: ClassBody;
    loc: SourceLocation | null;
}
AnonymousDefaultExportedFunctionDeclaration <: Function {
    type: "FunctionDeclaration";
    id: null;
    async: boolean;
    generator: boolean;
    params: [ Pattern ];
    body: FunctionBody;
    loc: SourceLocation | null;
}
ArrayExpression <: Expression {
    type: "ArrayExpression";
    elements: [ Expression | SpreadElement | null ];
    loc: SourceLocation | null;
}
ArrayPattern <: Pattern {
    type: "ArrayPattern";
    elements: [ Pattern | null ];
    loc: SourceLocation | null;
}
ArrowFunctionExpression <: Function, Expression {
    type: "ArrowFunctionExpression";
    body: FunctionBody | Expression;
    expression: boolean;
    loc: SourceLocation | null;
    async: boolean;
    generator: boolean;
    id: Identifier | null;
    params: [ Pattern ];
}
AssignmentExpression <: Expression {
    type: "AssignmentExpression";
    operator: AssignmentOperator;
    left: Pattern;
    right: Expression;
    loc: SourceLocation | null;
}
AssignmentOperator {
    "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**="
}
AssignmentPattern <: Pattern {
    type: "AssignmentPattern";
    left: Pattern;
    right: Expression;
    loc: SourceLocation | null;
}
AssignmentProperty <: Property {
    type: "Property"; // inherited
    value: Pattern;
    kind: "init";
    key: Expression;
    method: boolean;
    shorthand: boolean;
    computed: boolean;
    loc: SourceLocation | null;
}
AwaitExpression <: Expression {
    type: "AwaitExpression";
    argument: Expression;
    loc: SourceLocation | null;
}
BigIntLiteral <: Literal {
    bigint: string;
}
BinaryExpression <: Expression {
    type: "BinaryExpression";
    operator: BinaryOperator;
    left: Expression;
    right: Expression;
    loc: SourceLocation | null;
}
BinaryOperator {
    "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "|" | "^" | "&" | "in" | "instanceof" | "**"
}
BlockStatement <: Statement {
    type: "BlockStatement";
    body: [ Statement ];
    loc: SourceLocation | null;
}
BreakStatement <: Statement {
    type: "BreakStatement";
    label: Identifier | null;
    loc: SourceLocation | null;
}
CallExpression <: Expression, ChainElement {
    type: "CallExpression";
    callee: Expression | Super;
    arguments: [ Expression | SpreadElement ];
    loc: SourceLocation | null;
    optional: boolean;
}
CatchClause <: Node {
    type: "CatchClause";
    param: Pattern | null;
    body: BlockStatement;
    loc: SourceLocation | null;
}
ChainElement <: Node {
    optional: boolean;
    loc: SourceLocation | null;
}
ChainExpression <: Expression {
    type: "ChainExpression";
    expression: ChainElement;
    loc: SourceLocation | null;
}
Class <: Node {
    id: Identifier | null;
    superClass: Expression | null;
    body: ClassBody;
    loc: SourceLocation | null;
}
ClassBody <: Node {
    type: "ClassBody";
    body: [ MethodDefinition ];
    loc: SourceLocation | null;
}
ClassDeclaration <: Class, Declaration {
    type: "ClassDeclaration";
    id: Identifier;
    loc: SourceLocation | null;
    superClass: Expression | null;
    body: ClassBody;
}
ClassExpression <: Class, Expression {
    type: "ClassExpression";
    loc: SourceLocation | null;
    id: Identifier | null;
    superClass: Expression | null;
    body: ClassBody;
}
ConditionalExpression <: Expression {
    type: "ConditionalExpression";
    test: Expression;
    alternate: Expression;
    consequent: Expression;
    loc: SourceLocation | null;
}
ContinueStatement <: Statement {
    type: "ContinueStatement";
    label: Identifier | null;
    loc: SourceLocation | null;
}
DebuggerStatement <: Statement {
    type: "DebuggerStatement";
    loc: SourceLocation | null;
}
Declaration <: Statement {
    loc: SourceLocation | null;
}
Directive <: Node {
    type: "ExpressionStatement";
    expression: Literal;
    directive: string;
    loc: SourceLocation | null;
}
DoWhileStatement <: Statement {
    type: "DoWhileStatement";
    body: Statement;
    test: Expression;
    loc: SourceLocation | null;
}
EmptyStatement <: Statement {
    type: "EmptyStatement";
    loc: SourceLocation | null;
}
ExportAllDeclaration <: ModuleDeclaration {
    type: "ExportAllDeclaration";
    source: Literal;
    loc: SourceLocation | null;
    exported: Identifier | null;
}
ExportDefaultDeclaration <: ModuleDeclaration {
    type: "ExportDefaultDeclaration";
    loc: SourceLocation | null;
    declaration: AnonymousDefaultExportedFunctionDeclaration | FunctionDeclaration | AnonymousDefaultExportedClassDeclaration | ClassDeclaration | Expression;
}
ExportNamedDeclaration <: ModuleDeclaration {
    type: "ExportNamedDeclaration";
    declaration: Declaration | null;
    specifiers: [ ExportSpecifier ];
    source: Literal | null;
    loc: SourceLocation | null;
}
ExportSpecifier <: ModuleSpecifier {
    type: "ExportSpecifier";
    exported: Identifier;
    loc: SourceLocation | null;
    local: Identifier;
}
Expression <: Node {
    loc: SourceLocation | null;
}
ExpressionStatement <: Statement {
    type: "ExpressionStatement";
    expression: Expression;
    loc: SourceLocation | null;
}
ForInStatement <: Statement {
    type: "ForInStatement";
    left: VariableDeclaration |  Pattern;
    right: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
ForOfStatement <: ForInStatement {
    type: "ForOfStatement";
    await: boolean;
    left: VariableDeclaration |  Pattern;
    right: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
ForStatement <: Statement {
    type: "ForStatement";
    init: VariableDeclaration | Expression | null;
    test: Expression | null;
    update: Expression | null;
    body: Statement;
    loc: SourceLocation | null;
}
Function <: Node {
    async: boolean;
    generator: boolean;
    id: Identifier | null;
    params: [ Pattern ];
    body: FunctionBody;
    loc: SourceLocation | null;
}
FunctionBody <: BlockStatement {
    body: [ Directive | Statement ];
}
FunctionDeclaration <: Function, Declaration {
    type: "FunctionDeclaration";
    id: Identifier;
    loc: SourceLocation | null;
    async: boolean;
    generator: boolean;
    params: [ Pattern ];
    body: FunctionBody;
}
FunctionExpression <: Function, Expression {
    type: "FunctionExpression";
    loc: SourceLocation | null;
    async: boolean;
    generator: boolean;
    id: Identifier | null;
    params: [ Pattern ];
    body: FunctionBody;
}
Identifier <: Expression, Pattern {
    type: "Identifier";
    name: string;
    loc: SourceLocation | null;
}
IfStatement <: Statement {
    type: "IfStatement";
    test: Expression;
    consequent: Statement;
    alternate: Statement | null;
    loc: SourceLocation | null;
}
ImportDeclaration <: ModuleDeclaration {
    type: "ImportDeclaration";
    source: Literal;
    specifiers: [ ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier ];
    loc: SourceLocation | null;
}
ImportDefaultSpecifier <: ModuleSpecifier {
    type: "ImportDefaultSpecifier";
    loc: SourceLocation | null;
    local: Identifier;
}
ImportExpression <: Expression {
    type: "ImportExpression";
    source: Expression;
    loc: SourceLocation | null;
}
ImportNamespaceSpecifier <: ModuleSpecifier {
    type: "ImportNamespaceSpecifier";
    loc: SourceLocation | null;
    local: Identifier;
}
ImportSpecifier <: ModuleSpecifier {
    type: "ImportSpecifier";
    imported: Identifier;
    loc: SourceLocation | null;
    local: Identifier;
}
LabeledStatement <: Statement {
    type: "LabeledStatement";
    label: Identifier;
    body: Statement;
    loc: SourceLocation | null;
}
Literal <: Expression {
    type: "Literal";
    value: string | boolean | null | number | RegExp | bigint;
    loc: SourceLocation | null;
}
LogicalExpression <: Expression {
    type: "LogicalExpression";
    operator: LogicalOperator;
    left: Expression;
    right: Expression;
    loc: SourceLocation | null;
}
LogicalOperator {
    "||" | "&&" | "??"
}
MemberExpression <: Expression, Pattern, ChainElement {
    type: "MemberExpression";
    object: Expression | Super;
    property: Expression;
    computed: boolean;
    loc: SourceLocation | null;
    optional: boolean;
}
MetaProperty <: Expression {
    type: "MetaProperty";
    meta: Identifier;
    property: Identifier;
    loc: SourceLocation | null;
}
MethodDefinition <: Node {
    type: "MethodDefinition";
    key: Expression;
    value: FunctionExpression;
    kind: "constructor" | "method" | "get" | "set";
    computed: boolean;
    static: boolean;
    loc: SourceLocation | null;
}
ModuleDeclaration <: Node {
    loc: SourceLocation | null;
}
ModuleSpecifier <: Node {
    loc: SourceLocation | null;
    local: Identifier;
}
NewExpression <: Expression {
    type: "NewExpression";
    callee: Expression;
    arguments: [ Expression | SpreadElement ];
    loc: SourceLocation | null;
}
Node {
    loc: SourceLocation | null;
    type: string;
}
ObjectExpression <: Expression {
    type: "ObjectExpression";
    properties: [ Property | SpreadElement ];
    loc: SourceLocation | null;
}
ObjectPattern <: Pattern {
    type: "ObjectPattern";
    properties: [ AssignmentProperty | RestElement ];
    loc: SourceLocation | null;
}
Pattern <: Node {
    loc: SourceLocation | null;
}
Position {
    line: number; // >= 1;
    column: number; // >= 0;
}
Program <: Node {
    type: "Program";
    body: [ Directive | Statement ];
    loc: SourceLocation | null;
}
Property <: Node {
    type: "Property";
    key: Expression;
    method: boolean;
    shorthand: boolean;
    computed: boolean;
    value: Expression;
    kind: "init" | "get" | "set";
    loc: SourceLocation | null;
}
RegExpLiteral <: Literal {
    regex: {
        pattern: string;
        flags: string;
    };
}
RestElement <: Pattern {
    type: "RestElement";
    argument: Pattern;
    loc: SourceLocation | null;
}
ReturnStatement <: Statement {
    type: "ReturnStatement";
    argument: Expression | null;
    loc: SourceLocation | null;
}
SequenceExpression <: Expression {
    type: "SequenceExpression";
    expressions: [ Expression ];
    loc: SourceLocation | null;
}
SourceLocation {
    source: string | null;
    start: Position;
    end: Position;
}
SpreadElement <: Node {
    type: "SpreadElement";
    argument: Expression;
    loc: SourceLocation | null;
}
Statement <: Node {
    loc: SourceLocation | null;
}
Super <: Node {
    type: "Super";
    loc: SourceLocation | null;
}
SwitchCase <: Node {
    type: "SwitchCase";
    test: Expression | null;
    consequent: [ Statement ];
    loc: SourceLocation | null;
}
SwitchStatement <: Statement {
    type: "SwitchStatement";
    discriminant: Expression;
    cases: [ SwitchCase ];
    loc: SourceLocation | null;
}
TaggedTemplateExpression <: Expression {
    type: "TaggedTemplateExpression";
    tag: Expression;
    quasi: TemplateLiteral;
    loc: SourceLocation | null;
}
TemplateElement <: Node {
    type: "TemplateElement";
    tail: boolean;
    value: {
        cooked: string | null;
        raw: string;
    };
    loc: SourceLocation | null;
}
TemplateLiteral <: Expression {
    type: "TemplateLiteral";
    quasis: [ TemplateElement ];
    expressions: [ Expression ];
    loc: SourceLocation | null;
}
ThisExpression <: Expression {
    type: "ThisExpression";
    loc: SourceLocation | null;
}
ThrowStatement <: Statement {
    type: "ThrowStatement";
    argument: Expression;
    loc: SourceLocation | null;
}
TryStatement <: Statement {
    type: "TryStatement";
    block: BlockStatement;
    handler: CatchClause | null;
    finalizer: BlockStatement | null;
    loc: SourceLocation | null;
}
UnaryExpression <: Expression {
    type: "UnaryExpression";
    operator: UnaryOperator;
    prefix: boolean;
    argument: Expression;
    loc: SourceLocation | null;
}
UnaryOperator {
    "-" | "+" | "!" | "~" | "typeof" | "void" | "delete"
}
UpdateExpression <: Expression {
    type: "UpdateExpression";
    operator: UpdateOperator;
    argument: Expression;
    prefix: boolean;
    loc: SourceLocation | null;
}
UpdateOperator {
    "++" | "--"
}
VariableDeclaration <: Declaration {
    type: "VariableDeclaration";
    declarations: [ VariableDeclarator ];
    kind: "var" | "let" | "const";
    loc: SourceLocation | null;
}
VariableDeclarator <: Node {
    type: "VariableDeclarator";
    id: Pattern;
    init: Expression | null;
    loc: SourceLocation | null;
}
WhileStatement <: Statement {
    type: "WhileStatement";
    test: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
WithStatement <: Statement {
    type: "WithStatement";
    object: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
YieldExpression <: Expression {
    type: "YieldExpression";
    argument: Expression | null;
    delegate: boolean;
    loc: SourceLocation | null;
}

*/
