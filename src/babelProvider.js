
import { TextEditor } from 'atom'; // eslint-disable-line import/no-unresolved, no-unused-vars
import { TopScopeIdentifier } from './topScopeIdentifier';
import { Identifier } from './identifier';
import { EmptyIdentifier } from './emptyIdentifier';

const babelParser = require('@babel/parser');
// https://github.com/estree/estree

export class ProvidersRegistry {
    getProviderForTextEditor( textEditor ) {
        return new BabelProvider( textEditor );
    }
}

export class IdentifiersProvider {
    /**
     * Holds TextEditor instance this provider provides Identifiers for.
     * @type {TextEditor}
     *
     * @private
     */
    _textEditor = null;

    /**
     * Holds TopScopeIdentifier for TextEditor this provider provides for.
     * @type {TopScopeIdentifier}
     */
    _topScopeIdentifier = null;

    /**
     * Creates new IdentifierProvider for given TextEditor.
     * @param {TextEditor} textEditor
     */
    constructor( textEditor ) {
        if( !textEditor ) {
            throw new Error('textEditor argument must be valid instance of atom TextEditor!');
        }

        this._textEditor = textEditor;
        this._topScopeIdentifier = new TopScopeIdentifier( this._textEditor );
    }

    /**
     * Makes the Provider generate Identifiers for the TextEditor.
     *
     * @abstract
     * You want to override this function when creating custom IdentifiersProvider.
     * Perform parsing and populate the TopScopeIdentifier with Identifiers.
     */
    generateIdentifiers() {

    }

    /**
     * Returns TopScopeIdentifier with all Identifiers found in TextEditor's code.
     *
     * @return {TopScopeIdentifier} A TopScopeIdentifier for TextEditor.
     */
    getTopScopeIdentifier() {
        return this._topScopeIdentifier;
    }

    /**
     * Returns an array of all Identifiers which can have children
     * (classes, namespaces, enums etc.) found in TextEditor, with
     * TopScopeIdentifier at the top. TopScopeIdentifier is always
     * present in the array, even if Provider is not able to provide
     * any other Identifiers.
     *
     * @return {Array<Identifier>} An array with all parent Identifiers.
     */
    getIdentifiersForParentsDropbox() {
        const parents = this._topScopeIdentifier.getChildren().filter( (identifier) => {
            return identifier.canHaveChildren();
        });
        return [ this._topScopeIdentifier, ...parents ];
    }

    /**
     * Returns an array of all children of given parent `identifier`,
     * with {@link EmptyIdentifier} at the top. {@link EmptyIdentifier}
     * is always present in the array even if `identifier` otherwise
     * have no other children.
     *
     * Returns **null** if `identifier` cannot have children, ie. is
     * child of some parent itself...
     *
     * @param  {Identifier} identifier  The parent Identifier we're getting children of.
     * @return {Array<Identifier>|null} Returns null if identifier cannot have children.
     */
    getIdentifiersForChildrenDropbox( identifier ) {
        if( !identifier ) {
            throw new Error('identifier argument muse be valid instance of Identifier!');
        }

        // Must be parent to have children...
        if( !identifier.canHaveChildren() ) {
            return null;
        }

        const children = identifier.getChildren().filter( (child) => {
            return !child.canHaveChildren();
        });
        return [ new EmptyIdentifier(identifier), ...children ];
    }
}

/**
 * Provider uses Babel for parsing source code. It handles javascript, typescript and flow.
 */
export class BabelProvider extends IdentifiersProvider {
    /**
     * Holds esTree generated by Babel.
     * @type {object}
     */
    _esTree = null;

    /**
     * Holds instance of current Identifier. It's either TopScopeIdentifier,
     * a parent Identifier which can have children, or child Identifier.
     * @type {Identifier}
     */
    _currentIdentifier = null;

    /**
     * Holds instance of current EsTree node provider is processing.
     * @type {Object}
     */
    _currentEsTreeNode = null;

    /**
     * @override
     */
    generateIdentifiers() {
        this._topScopeIdentifier.removeAllChildren();
        this.parse();
        this.processEsTree();

        console.log(
            'BabelProvider finished',
            this._topScopeIdentifier
        );
    }

    /**
     * Parses source code from TextEditor with Babel.
     *
     * @private
     */
    parse() {
        const parserOptions = {
            errorRecovery: true,
            sourceType: 'module',
            plugins: [
                'asyncGenerators',
                'bigInt',
                'classProperties',
                'classPrivateProperties',
                'classPrivateMethods',
                [ 'decorators', { decoratorsBeforeExport: false } ],
                'doExpressions',
                'dynamicImport',
                'exportDefaultFrom',
                'exportNamespaceFrom',
                'functionBind',
                'functionSent',
                'importMeta',
                'logicalAssignment',
                'nullishCoalescingOperator',
                'numericSeparator',
                'objectRestSpread',
                'optionalCatchBinding',
                'optionalChaining',
                'partialApplication',
                //'pipelineOperator',
                'throwExpressions',
                'topLevelAwait'
            ]
        };

        try {
            this._esTree = babelParser.parse( this._textEditor.getBuffer().getText(), parserOptions );
        } catch( error ) {
            console.error( 'BabelProvider::parse caught exception:', error );
            this._esTree = null;
        }
    }

    /**
     * Processes EsTree generated by Babel, if parsing produced one.
     *
     * @private
     */
    processEsTree() {
        if( !this._esTree ) return;

        this._currentEsTreeNode = this._esTree;
        this._currentIdentifier = this._topScopeIdentifier;

        this.processCurrentNode();
    }

    /**
     * Processes current EsTree node, if any is available for processing.
     *
     * @private
     */
    processCurrentNode() {
        while( this._currentEsTreeNode ) {

            switch( this._currentEsTreeNode.type ) {
            case 'File':
                this.consumeFile();
                break;
            case 'Program':
                this.consumeProgram();
                break;
            case 'VariableDeclaration':
                this.consumeVariableDeclaration();
                break;
            case 'ClassDeclaration':
                this.consumeClassDeclaration();
                break;
            case 'FunctionDeclaration':
                this.consumeFunctionDeclaration();
                break;
            case 'ExpressionStatement':
                this.consumeExpressionStatement();
                break;
            case 'ImportDeclaration':
                this.consumeImportDeclaration();
                break;
            case 'ExportNamedDeclaration':
                this.consumeExportNamedDeclaration();
                break;
            case 'ExportDefaultDeclaration':
                this.consumeExportDefaultDeclaration();
                break;
                // Following node types are skipped from processing for identifiers.
                // Fallthrough intential
            case 'ForOfStatement':
            case 'ForInStatement':
                this._currentEsTreeNode = null;
                break;
            default:
                console.warn( 'BabelProvider::processNode: Unknown node type!', this._currentEsTreeNode.type );
                console.info( this._currentEsTreeNode );
                this._currentEsTreeNode = null;
            }

        }
    }

    /*
        File:
        .comments   {Array}
        .end        {number}
        .errors     {Array}
        .loc        SourceLocation{start:{line,column}, end:{line,column}, source: string|null}
        .program    {Node}
        .start      {number}
        .type       'File'
     */
    consumeFile() {
        // Nothing to add yet...
        this._currentEsTreeNode = this._currentEsTreeNode.program;
    }

    /*
        Program {
            body: [ Statement | ModuleDeclaration ];
            loc: SourceLocation | null;
            sourceType: "script" | "module";
            type: string;
        }

        Program:
        .body           {Array}
        .directives     {Array}
        .end            {number}
        .interpreter    {null}
        .loc            SourceLocation{start:{line,column}, end:{line,column}, source: string|null}
        .sourceType     ['module','script']
        .start          {number}
        .type           'Program'
     */
    consumeProgram() {
        // Nothing to add yet...
        for( const node of this._currentEsTreeNode.body ) {
            this._currentEsTreeNode = node;
            this.processCurrentNode();
        }
    }

    consumeExportDefaultDeclaration() {
        console.info( 'TODO: implement ExportDefaultDeclaration' );
        this._currentEsTreeNode = null;
    }

    /*
        ExportNamedDeclaration <: ModuleDeclaration {
            type: "ExportNamedDeclaration";
            declaration: Declaration | null;
            specifiers: [ ExportSpecifier ];
            source: Literal | null;
            loc: SourceLocation | null;
        }

        ExportSpecifier <: ModuleSpecifier {
            type: "ExportSpecifier";
            exported: Identifier;
            loc: SourceLocation | null;
            local: Identifier;
        }

        Declaration <: Statement {
            loc: SourceLocation | null;
        }

        Declaration: ClassDeclaration | FunctionDeclaration | VariableDeclaration

        ExportNamedDeclaration:
        .declaration        {Node}
        .end                {number}
        .loc                SourceLocation{start:{line,column}, end:{line,column}, source: string|null}
        .source             {Literal|null}
        .specifiers         {Array}
        .start              {number}
        .trailingComments   ['CommentBlock']
        .type               'ExportNamedDeclaration'
     */
    consumeExportNamedDeclaration() {
        // check specifiers?
        if( this._currentEsTreeNode.declaration !== null ) {
            this._currentEsTreeNode = this._currentEsTreeNode.declaration;
            this.consumeDeclaration();
        } else {
            // export { constOne, varOne, letOne, constTwo };
            // export { constOne as renamedOne, varOne as renamedTwo, letOne as renamedThree, constTwo as renamedFour };
            this._currentEsTreeNode = null;
        }
    }

    consumeDeclaration() {
        switch( this._currentEsTreeNode.type ) {
        case 'VariableDeclaration':
            this.consumeVariableDeclaration();
            break;
        case 'ClassDeclaration':
            this.consumeClassDeclaration();
            break;
        case 'FunctionDeclaration':
            this.consumeFunctionDeclaration();
            break;
        default:
            console.warn( 'BabelProvider::consumeDeclaration: Unknown declaration type!', this._currentEsTreeNode.type );
            console.info( this._currentEsTreeNode );
            this._currentEsTreeNode = null;
        }
    }

    /*
        VariableDeclaration <: Declaration {
            type: "VariableDeclaration";
            declarations: [ VariableDeclarator ];
            kind: "var" | "let" | "const";
            loc: SourceLocation | null;
        }

        VariableDeclarator <: Node {
            type: "VariableDeclarator";
            id: Pattern;
            init: Expression | null;
            loc: SourceLocation | null;
        }
     */
    consumeVariableDeclaration() {
        console.log('BabelProvider::consumeVariableDeclaration');
        const variableDeclaration = this._currentEsTreeNode;
        for( const variableDeclarator of this._currentEsTreeNode.declarations ) {
            if( variableDeclarator.type === 'VariableDeclarator' ) {
                this._currentEsTreeNode = variableDeclarator.id;
                this.consumePattern();
                this._currentIdentifier.addKind( variableDeclaration.kind );
                this._currentIdentifier = this._currentIdentifier.getParent();
            } else {
                console.warn( 'BabelProvider::consumeVariableDeclaration: expected VariableDeclarator as type of node!', variableDeclarator.type );
                console.info( variableDeclarator );
            }
        }

        this._currentEsTreeNode = null;
    }

    consumeClassDeclaration() {
        console.info( 'TODO: implement ClassDeclaration' );
        this._currentEsTreeNode = null;
    }

    consumeFunctionDeclaration() {
        console.info( 'TODO: implement FunctionDeclaration' );
        this._currentEsTreeNode = null;
    }

    consumeImportDeclaration() {
        console.info( 'TODO: implement ImportDeclaration' );
        this._currentEsTreeNode = null;
    }

    /*
        ExpressionStatement <: Statement {
            type: "ExpressionStatement";
            expression: Expression;
            loc: SourceLocation | null;
        }
     */
    consumeExpressionStatement() {
        console.info( 'TODO: implement ExpressionStatement' );
        this._currentEsTreeNode = null;
    }

    /*
        Pattern: ArrayPattern | AssignmentPattern | Identifier | MemberExpression | ObjectPattern | RestElement

        ArrayPattern <: Pattern {
            type: "ArrayPattern";
            elements: [ Pattern | null ];
            loc: SourceLocation | null;
        }

        AssignmentPattern <: Pattern {
            type: "AssignmentPattern";
            left: Pattern;
            right: Expression;
            loc: SourceLocation | null;
        }

        Identifier <: Expression, Pattern {
            type: "Identifier";
            name: string;
            loc: SourceLocation | null;
        }

        MemberExpression <: Expression, Pattern, ChainElement {
            type: "MemberExpression";
            object: Expression | Super;
            property: Expression;
            computed: boolean;
            loc: SourceLocation | null;
            optional: boolean;
        }

        ObjectPattern <: Pattern {
            type: "ObjectPattern";
            properties: [ AssignmentProperty | RestElement ];
            loc: SourceLocation | null;
        }

        RestElement <: Pattern {
            type: "RestElement";
            argument: Pattern;
            loc: SourceLocation | null;
        }

     */
    consumePattern() {
        switch( this._currentEsTreeNode.type ) {
        case 'Identifier':
            this._currentIdentifier = this.addNewChildIdentifier().setName(this._currentEsTreeNode.name);
            break;
        case 'ArrayPattern':
            // TODO: implement
            this._currentIdentifier = this.addNewChildIdentifier().setName('array');
            break;
        case 'AssignmentPattern':
            // TODO: implement
            this._currentIdentifier = this.addNewChildIdentifier().setName('assignment');
            break;
        case 'MemberExpression':
            // TODO: implement
            this._currentIdentifier = this.addNewChildIdentifier().setName('member');
            break;
        case 'ObjectPattern':
            // TODO: implement
            this._currentIdentifier = this.addNewChildIdentifier().setName('object');
            break;
        case 'RestElement':
            // TODO: implement
            this._currentIdentifier = this.addNewChildIdentifier().setName('rest');
            break;
        default:
            console.warn( 'BabelProvider::consumePattern: Unknown Pattern type!', this._currentEsTreeNode.type );
            console.info( this._currentEsTreeNode );
        }
    }

    /**
     * Adds a new Identifier which can have children to a given `parentIdentifier`.
     * If `parentIdentifier` is empty, identifier will be added to the current Identifier.
     */
    addNewParentIdentifier( parentIdentifier ) {
        if( !parentIdentifier ) parentIdentifier = this._currentIdentifier;

        const identifier = new Identifier({ textEditor: this._textEditor, canHaveChildren: true, parent: parentIdentifier });
        this._topScopeIdentifier.addChild( identifier );
        return identifier;
    }

    /**
     * Adds a new Identifier which is child and **cannot*** have children to a given `parentIdentifier`.
     * If `parentIdentifier` is empty, identifier will be added to the current Identifier.
     */
    addNewChildIdentifier( parentIdentifier ) {
        if( !parentIdentifier ) parentIdentifier = this._currentIdentifier;

        const identifier = new Identifier({ textEditor: this._textEditor, canHaveChildren: false, parent: parentIdentifier });
        parentIdentifier.addChild( identifier );
        return identifier;
    }
}



/*

Declaration: ClassDeclaration | FunctionDeclaration | VariableDeclaration
Pattern: ArrayPattern | AssignmentPattern | Identifier | MemberExpression | ObjectPattern | RestElement

AnonymousDefaultExportedClassDeclaration <: Class {
    type: "ClassDeclaration";
    id: null;
    superClass: Expression | null;
    body: ClassBody;
    loc: SourceLocation | null;
}
AnonymousDefaultExportedFunctionDeclaration <: Function {
    type: "FunctionDeclaration";
    id: null;
    async: boolean;
    generator: boolean;
    params: [ Pattern ];
    body: FunctionBody;
    loc: SourceLocation | null;
}
ArrayExpression <: Expression {
    type: "ArrayExpression";
    elements: [ Expression | SpreadElement | null ];
    loc: SourceLocation | null;
}
ArrayPattern <: Pattern {
    type: "ArrayPattern";
    elements: [ Pattern | null ];
    loc: SourceLocation | null;
}
ArrowFunctionExpression <: Function, Expression {
    type: "ArrowFunctionExpression";
    body: FunctionBody | Expression;
    expression: boolean;
    loc: SourceLocation | null;
    async: boolean;
    generator: boolean;
    id: Identifier | null;
    params: [ Pattern ];
}
AssignmentExpression <: Expression {
    type: "AssignmentExpression";
    operator: AssignmentOperator;
    left: Pattern;
    right: Expression;
    loc: SourceLocation | null;
}
AssignmentOperator {
    "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**="
}
AssignmentPattern <: Pattern {
    type: "AssignmentPattern";
    left: Pattern;
    right: Expression;
    loc: SourceLocation | null;
}
AssignmentProperty <: Property {
    type: "Property"; // inherited
    value: Pattern;
    kind: "init";
    key: Expression;
    method: boolean;
    shorthand: boolean;
    computed: boolean;
    loc: SourceLocation | null;
}
AwaitExpression <: Expression {
    type: "AwaitExpression";
    argument: Expression;
    loc: SourceLocation | null;
}
BigIntLiteral <: Literal {
    bigint: string;
}
BinaryExpression <: Expression {
    type: "BinaryExpression";
    operator: BinaryOperator;
    left: Expression;
    right: Expression;
    loc: SourceLocation | null;
}
BinaryOperator {
    "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "|" | "^" | "&" | "in" | "instanceof" | "**"
}
BlockStatement <: Statement {
    type: "BlockStatement";
    body: [ Statement ];
    loc: SourceLocation | null;
}
BreakStatement <: Statement {
    type: "BreakStatement";
    label: Identifier | null;
    loc: SourceLocation | null;
}
CallExpression <: Expression, ChainElement {
    type: "CallExpression";
    callee: Expression | Super;
    arguments: [ Expression | SpreadElement ];
    loc: SourceLocation | null;
    optional: boolean;
}
CatchClause <: Node {
    type: "CatchClause";
    param: Pattern | null;
    body: BlockStatement;
    loc: SourceLocation | null;
}
ChainElement <: Node {
    optional: boolean;
    loc: SourceLocation | null;
}
ChainExpression <: Expression {
    type: "ChainExpression";
    expression: ChainElement;
    loc: SourceLocation | null;
}
Class <: Node {
    id: Identifier | null;
    superClass: Expression | null;
    body: ClassBody;
    loc: SourceLocation | null;
}
ClassBody <: Node {
    type: "ClassBody";
    body: [ MethodDefinition ];
    loc: SourceLocation | null;
}
ClassDeclaration <: Class, Declaration {
    type: "ClassDeclaration";
    id: Identifier;
    loc: SourceLocation | null;
    superClass: Expression | null;
    body: ClassBody;
}
ClassExpression <: Class, Expression {
    type: "ClassExpression";
    loc: SourceLocation | null;
    id: Identifier | null;
    superClass: Expression | null;
    body: ClassBody;
}
ConditionalExpression <: Expression {
    type: "ConditionalExpression";
    test: Expression;
    alternate: Expression;
    consequent: Expression;
    loc: SourceLocation | null;
}
ContinueStatement <: Statement {
    type: "ContinueStatement";
    label: Identifier | null;
    loc: SourceLocation | null;
}
DebuggerStatement <: Statement {
    type: "DebuggerStatement";
    loc: SourceLocation | null;
}
Declaration <: Statement {
    loc: SourceLocation | null;
}
Directive <: Node {
    type: "ExpressionStatement";
    expression: Literal;
    directive: string;
    loc: SourceLocation | null;
}
DoWhileStatement <: Statement {
    type: "DoWhileStatement";
    body: Statement;
    test: Expression;
    loc: SourceLocation | null;
}
EmptyStatement <: Statement {
    type: "EmptyStatement";
    loc: SourceLocation | null;
}
ExportAllDeclaration <: ModuleDeclaration {
    type: "ExportAllDeclaration";
    source: Literal;
    loc: SourceLocation | null;
    exported: Identifier | null;
}
ExportDefaultDeclaration <: ModuleDeclaration {
    type: "ExportDefaultDeclaration";
    loc: SourceLocation | null;
    declaration: AnonymousDefaultExportedFunctionDeclaration | FunctionDeclaration | AnonymousDefaultExportedClassDeclaration | ClassDeclaration | Expression;
}

    ExportNamedDeclaration <: ModuleDeclaration {
        type: "ExportNamedDeclaration";
        declaration: Declaration | null;
        specifiers: [ ExportSpecifier ];
        source: Literal | null;
        loc: SourceLocation | null;
    }

    ExportSpecifier <: ModuleSpecifier {
        type: "ExportSpecifier";
        exported: Identifier;
        loc: SourceLocation | null;
        local: Identifier;
    }

Expression <: Node {
    loc: SourceLocation | null;
}
ExpressionStatement <: Statement {
    type: "ExpressionStatement";
    expression: Expression;
    loc: SourceLocation | null;
}
ForInStatement <: Statement {
    type: "ForInStatement";
    left: VariableDeclaration |  Pattern;
    right: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
ForOfStatement <: ForInStatement {
    type: "ForOfStatement";
    await: boolean;
    left: VariableDeclaration |  Pattern;
    right: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
ForStatement <: Statement {
    type: "ForStatement";
    init: VariableDeclaration | Expression | null;
    test: Expression | null;
    update: Expression | null;
    body: Statement;
    loc: SourceLocation | null;
}
Function <: Node {
    async: boolean;
    generator: boolean;
    id: Identifier | null;
    params: [ Pattern ];
    body: FunctionBody;
    loc: SourceLocation | null;
}
FunctionBody <: BlockStatement {
    body: [ Directive | Statement ];
}
FunctionDeclaration <: Function, Declaration {
    type: "FunctionDeclaration";
    id: Identifier;
    loc: SourceLocation | null;
    async: boolean;
    generator: boolean;
    params: [ Pattern ];
    body: FunctionBody;
}
FunctionExpression <: Function, Expression {
    type: "FunctionExpression";
    loc: SourceLocation | null;
    async: boolean;
    generator: boolean;
    id: Identifier | null;
    params: [ Pattern ];
    body: FunctionBody;
}
Identifier <: Expression, Pattern {
    type: "Identifier";
    name: string;
    loc: SourceLocation | null;
}
IfStatement <: Statement {
    type: "IfStatement";
    test: Expression;
    consequent: Statement;
    alternate: Statement | null;
    loc: SourceLocation | null;
}
ImportDeclaration <: ModuleDeclaration {
    type: "ImportDeclaration";
    source: Literal;
    specifiers: [ ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier ];
    loc: SourceLocation | null;
}
ImportDefaultSpecifier <: ModuleSpecifier {
    type: "ImportDefaultSpecifier";
    loc: SourceLocation | null;
    local: Identifier;
}
ImportExpression <: Expression {
    type: "ImportExpression";
    source: Expression;
    loc: SourceLocation | null;
}
ImportNamespaceSpecifier <: ModuleSpecifier {
    type: "ImportNamespaceSpecifier";
    loc: SourceLocation | null;
    local: Identifier;
}
ImportSpecifier <: ModuleSpecifier {
    type: "ImportSpecifier";
    imported: Identifier;
    loc: SourceLocation | null;
    local: Identifier;
}
LabeledStatement <: Statement {
    type: "LabeledStatement";
    label: Identifier;
    body: Statement;
    loc: SourceLocation | null;
}
Literal <: Expression {
    type: "Literal";
    value: string | boolean | null | number | RegExp | bigint;
    loc: SourceLocation | null;
}
LogicalExpression <: Expression {
    type: "LogicalExpression";
    operator: LogicalOperator;
    left: Expression;
    right: Expression;
    loc: SourceLocation | null;
}
LogicalOperator {
    "||" | "&&" | "??"
}
MemberExpression <: Expression, Pattern, ChainElement {
    type: "MemberExpression";
    object: Expression | Super;
    property: Expression;
    computed: boolean;
    loc: SourceLocation | null;
    optional: boolean;
}
MetaProperty <: Expression {
    type: "MetaProperty";
    meta: Identifier;
    property: Identifier;
    loc: SourceLocation | null;
}
MethodDefinition <: Node {
    type: "MethodDefinition";
    key: Expression;
    value: FunctionExpression;
    kind: "constructor" | "method" | "get" | "set";
    computed: boolean;
    static: boolean;
    loc: SourceLocation | null;
}
ModuleDeclaration <: Node {
    loc: SourceLocation | null;
}
ModuleSpecifier <: Node {
    loc: SourceLocation | null;
    local: Identifier;
}
NewExpression <: Expression {
    type: "NewExpression";
    callee: Expression;
    arguments: [ Expression | SpreadElement ];
    loc: SourceLocation | null;
}
Node {
    loc: SourceLocation | null;
    type: string;
}
ObjectExpression <: Expression {
    type: "ObjectExpression";
    properties: [ Property | SpreadElement ];
    loc: SourceLocation | null;
}
ObjectPattern <: Pattern {
    type: "ObjectPattern";
    properties: [ AssignmentProperty | RestElement ];
    loc: SourceLocation | null;
}
Pattern <: Node {
    loc: SourceLocation | null;
}
Position {
    line: number; // >= 1;
    column: number; // >= 0;
}
Program <: Node {
    type: "Program";
    body: [ Directive | Statement ];
    loc: SourceLocation | null;
}
Property <: Node {
    type: "Property";
    key: Expression;
    method: boolean;
    shorthand: boolean;
    computed: boolean;
    value: Expression;
    kind: "init" | "get" | "set";
    loc: SourceLocation | null;
}
RegExpLiteral <: Literal {
    regex: {
        pattern: string;
        flags: string;
    };
}
RestElement <: Pattern {
    type: "RestElement";
    argument: Pattern;
    loc: SourceLocation | null;
}
ReturnStatement <: Statement {
    type: "ReturnStatement";
    argument: Expression | null;
    loc: SourceLocation | null;
}
SequenceExpression <: Expression {
    type: "SequenceExpression";
    expressions: [ Expression ];
    loc: SourceLocation | null;
}
SourceLocation {
    source: string | null;
    start: Position;
    end: Position;
}
SpreadElement <: Node {
    type: "SpreadElement";
    argument: Expression;
    loc: SourceLocation | null;
}
Statement <: Node {
    loc: SourceLocation | null;
}
Super <: Node {
    type: "Super";
    loc: SourceLocation | null;
}
SwitchCase <: Node {
    type: "SwitchCase";
    test: Expression | null;
    consequent: [ Statement ];
    loc: SourceLocation | null;
}
SwitchStatement <: Statement {
    type: "SwitchStatement";
    discriminant: Expression;
    cases: [ SwitchCase ];
    loc: SourceLocation | null;
}
TaggedTemplateExpression <: Expression {
    type: "TaggedTemplateExpression";
    tag: Expression;
    quasi: TemplateLiteral;
    loc: SourceLocation | null;
}
TemplateElement <: Node {
    type: "TemplateElement";
    tail: boolean;
    value: {
        cooked: string | null;
        raw: string;
    };
    loc: SourceLocation | null;
}
TemplateLiteral <: Expression {
    type: "TemplateLiteral";
    quasis: [ TemplateElement ];
    expressions: [ Expression ];
    loc: SourceLocation | null;
}
ThisExpression <: Expression {
    type: "ThisExpression";
    loc: SourceLocation | null;
}
ThrowStatement <: Statement {
    type: "ThrowStatement";
    argument: Expression;
    loc: SourceLocation | null;
}
TryStatement <: Statement {
    type: "TryStatement";
    block: BlockStatement;
    handler: CatchClause | null;
    finalizer: BlockStatement | null;
    loc: SourceLocation | null;
}
UnaryExpression <: Expression {
    type: "UnaryExpression";
    operator: UnaryOperator;
    prefix: boolean;
    argument: Expression;
    loc: SourceLocation | null;
}
UnaryOperator {
    "-" | "+" | "!" | "~" | "typeof" | "void" | "delete"
}
UpdateExpression <: Expression {
    type: "UpdateExpression";
    operator: UpdateOperator;
    argument: Expression;
    prefix: boolean;
    loc: SourceLocation | null;
}
UpdateOperator {
    "++" | "--"
}
VariableDeclaration <: Declaration {
    type: "VariableDeclaration";
    declarations: [ VariableDeclarator ];
    kind: "var" | "let" | "const";
    loc: SourceLocation | null;
}
VariableDeclarator <: Node {
    type: "VariableDeclarator";
    id: Pattern;
    init: Expression | null;
    loc: SourceLocation | null;
}
WhileStatement <: Statement {
    type: "WhileStatement";
    test: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
WithStatement <: Statement {
    type: "WithStatement";
    object: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
YieldExpression <: Expression {
    type: "YieldExpression";
    argument: Expression | null;
    delegate: boolean;
    loc: SourceLocation | null;
}

*/
